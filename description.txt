
Структура данных:		
NestedStringElement
{NestedString} {NestedLevel} {List<NestedStringElement>}
													 
Создатель детей из строки:
1. Получаем стартовую и финишную координату:
	1.1. Ищем первую скобку в буферной строке (остатке буферной строки), записываем координату в стартовую координату, записываем +1 в количество скобок. Если не нашли, то соси пизду.
	1.2. Если скобка не открывающая, выбиваем ошибку.
	1.3. Удаляем скобку из строки.
	1.4. Ищем открывающую скобку или закрывающую.
	1.5. Если нашли открывающую, записываем +1 в количество скобок, записываем координату в промежуточную координату, удаляем символ по этой координате из строки.
	1.6. Если нашли закрывающую, записывааем -1 в количество скобок записываем координату в промежуточную координату, удаляем символ по этой координате из строки.
	1.7. Если количество скобок стало = 0, финишная координата = промежуточная координата.
	1.8. Если количество скобок > 0, перейти на шаг 1.4. 
2. Вырезаем кусок из буферной строки от стартовой до финишной координаты (исключительно), создаем ребенка и пишем кусок в NestedString ребенка, добавляем этого ребенка.
3. Если поиск в 1.1. пососал пизду, то берем остаток буферной строки и возвращаем.

Определение максимального уровня вложенности:

Создание дерева:
1. Получить максимальный уровень вложенности. Если = 0, то к пункту 2.
2. Обработка детей:	
	2.1. Передали буферную строку в создатель детей.
	2.2. Записали остаток буферной строки в NestedString на текущем уровне.
	2.3. Если дети созданы, получаем список детей с уровнем вложенности = текущий уровень + 1
	2.4. Если дети не созданы, завершить создание детей
3. Если максимальный уровень вложенности > 0, то получить лист детей на максимальном уровне вложенности.
4. Для каждого ребенка из листа детей провести обработку из п.2. 
5. Если ни для одного ребенка из листа дети не созданы, завершить создание дерева.

