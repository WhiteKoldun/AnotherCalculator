
Структура данных:		
NestedStringElement
{NestedString} {NestedLevel} {List<NestedStringElement>}
													 
ChildrenCreator (из строки).
Вход: строка
Выход: лист деревьев без детей
Алгоритм:
1. Получаем стартовую и финишную координату:
	1.1. Ищем первую скобку в буферной строке (остатке буферной строки), записываем координату в стартовую координату, записываем +1 в количество скобок. Если не нашли, то соси пизду.
	1.2. Если скобка не открывающая, выбиваем ошибку.
	1.3. Удаляем скобку из строки.
	1.4. Ищем открывающую скобку или закрывающую.
	1.5. Если нашли открывающую, записываем +1 в количество скобок, записываем координату в промежуточную координату, удаляем символ по этой координате из строки.
	1.6. Если нашли закрывающую, записывааем -1 в количество скобок записываем координату в промежуточную координату, удаляем символ по этой координате из строки.
	1.7. Если количество скобок стало = 0, финишная координата = промежуточная координата.
	1.8. Если количество скобок > 0, перейти на шаг 1.4. 
2. Вырезаем кусок из буферной строки от стартовой до финишной координаты (исключительно), создаем ребенка и пишем кусок в NestedString ребенка, добавляем этого ребенка.
3. Если поиск в 1.1. пососал пизду, то берем остаток буферной строки и возвращаем.
---------------------------------------------------------------------------------------------


GenerateTree
Вход: строка
Выход: дерево
Алгоритм:
1. Получить максимальный уровень вложенности. Если = 0, то к пункту 2.
2. Обработка детей:	
	2.1. Передали буферную строку в создатель детей.
	2.2. Записали остаток буферной строки в NestedString на текущем уровне.
	2.3. Если дети созданы, получаем список детей с уровнем вложенности = текущий уровень + 1
	2.4. Если дети не созданы, завершить создание детей
3. Если максимальный уровень вложенности > 0, то получить лист детей на максимальном уровне вложенности.
4. Для каждого ребенка из листа детей провести обработку из п.2. 
5. Если ни для одного ребенка из листа дети не созданы, завершить создание дерева.
---------------------------------------------------------------------------------------------

GetMaxNestedLevel (Определение максимального уровня вложенности:)
Вход: this (это метод типа дерева)
Выход: максимальный уровень вложенности среди всех веток дерева
Алгоритм:
1. Проверяем, что произвольынй уровень <= максимальный уровень вложенности дерева.
2. Начинаем с нуля, получаем список детей с нулевого уровня. Устанавливаем уровень вложенности = 1 
3. Если уровень вложенности = требуемый уровень, возвращаем список детей.
4. Если уровень вложенности < требуемый уровень, для каждого ребенка из списка детей:
	4.1. Получить список детей у ребенка
	4.2. Добавить каждого ребенка из полученного списка в буферный список.
	4.3. Когда прошли весь список детей, делаем список детей = буферный список.
	4.4. Устанавливам уровень вложенности = уровень вложенности + 1, переходим к п.4.
---------------------------------------------------------------------------------------------	
GetChildrenFromLevel
Вход: номер уровня (отсчет от 0), this NestedStringElement.
Выход: лист NestedStringElement на указанном уровне
Алгоритм:
1. Если номер уровня = 0, возвращаем этот NestedStringElement (путем добавления в лист возврата одного этого элемента, returnList.Add(this.NestedStringElement))
2. Если номер уровня = 1, возвращаем этот NestedStringElement.Children (returnList = NestedStringElement.Children)
3. Если номер уровня > 1, то:
	3.1. Получаем в качестве списка детей этот NestedStringElement.Children (bufferList = this.Children)
	3.2. Берем нулевой элемент буферного списка, проверяем его NestedLevel на соответствие требуемому. Если соответствует - возвращаем bufferList.
	3.3. Если нет:
		3.3.1 Обнулить returnList
		3.3.2 для каждого элемента bufferList:
			3.3.2.1 добавляем детей элемента в returnList
		3.3.3 когда цикл 3.3.2 закончен, делаем bufferList = returnList
---------------------------------------------------------------------------------------------





































