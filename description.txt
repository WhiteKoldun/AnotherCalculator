Неудача, надо все переделать с начала. Единственное хорошее место - разбитие строки на то, что должно быть вложено, и на то, что должно остаться на этом уровне.
О чем я не подумал:
- недостаточно просто разбить выражение на дерево. Надо в исходное выражение вместо скобки в итоге подставить полученное число, именно в то место, где была скобка.
- дерево вообще не нужно. Нужно обрабатывать строку с выражением столько раз, пока в ней не останется скобок.
- нужна проверка, что перед и после скобки стоит арифметический оператор либо скобка.
- не нужна настолько подробкая документация, она устаревает моментально. Максимум надо короткое резюме, и что метод получает и выдает.


Структура данных:		
NestedStringElement
{NestedString} {NestedLevel} {List<NestedStringElement>}
													 
1+2((12+13)123+143+(22+34))+(1+2(3+4))
1+2+(1+2(3+4))

													 
ChildrenCreator (из строки).
Вход: Материнский элемент без детей
Выход: лист детей, с проставленной ссылкой на материнский элемент
Алгоритм:
1. Получаем стартовую и финишную координату:
	1.1. Ищем первую скобку в буферной строке (остатке буферной строки), записываем координату в стартовую координату, записываем +1 в количество скобок. Если не нашли, то соси пизду.
	1.2. Если скобка не открывающая, выбиваем ошибку.
	1.3. Удаляем скобку из строки.
	1.4. Ищем открывающую скобку или закрывающую.
	1.5. Если нашли открывающую, записываем +1 в количество скобок, записываем координату в промежуточную координату, удаляем символ по этой координате из строки.
	1.6. Если нашли закрывающую, записывааем -1 в количество скобок записываем координату в промежуточную координату, удаляем символ по этой координате из строки.
	1.7. Если количество скобок стало = 0, финишная координата = промежуточная координата.
	1.8. Если количество скобок > 0, перейти на шаг 1.4. 
2. Вырезаем кусок из буферной строки от стартовой до финишной координаты (исключительно), создаем ребенка и пишем кусок в NestedString ребенка, добавляем этого ребенка.
3. Если поиск в 1.1. пососал пизду, то берем остаток буферной строки и возвращаем.
---------------------------------------------------------------------------------------------


GenerateTree
Вход: строка
Выход: дерево
Алгоритм:
1. Если в строке нет скобок - добавляем ее на нулевой уровень, завершаем создание
2. Если в строке одна пара скобок - с помощью создателя детей вытаскиваем ее и помещаем в ребенка один элемент.
3. Если в строке более одной пары скобок:
	3.1. 
---------------------------------------------------------------------------------------------

+ GetMaxNestedLevel (Определение максимального уровня вложенности:)
Вход: this (это метод типа дерева)
Выход: максимальный уровень вложенности среди всех веток дерева
Алгоритм:
1. Проверяем, что произвольынй уровень <= максимальный уровень вложенности дерева.
2. Начинаем с нуля, получаем список детей с нулевого уровня. Устанавливаем уровень вложенности = 1 
3. Если уровень вложенности = требуемый уровень, возвращаем список детей.
4. Если уровень вложенности < требуемый уровень, для каждого ребенка из списка детей:
	4.1. Получить список детей у ребенка
	4.2. Добавить каждого ребенка из полученного списка в буферный список.
	4.3. Когда прошли весь список детей, делаем список детей = буферный список.
	4.4. Устанавливам уровень вложенности = уровень вложенности + 1, переходим к п.4.
---------------------------------------------------------------------------------------------	
+ GetChildrenFromLevel
Вход: номер уровня (отсчет от 0), this NestedStringElement.
Выход: лист NestedStringElement на указанном уровне
Алгоритм:
1. Если номер уровня = 0, возвращаем этот NestedStringElement (путем добавления в лист возврата одного этого элемента, returnList.Add(this.NestedStringElement))
2. Если номер уровня = 1, возвращаем этот NestedStringElement.Children (returnList = NestedStringElement.Children)
3. Если номер уровня > 1, то:
	3.1. Получаем в качестве списка детей этот NestedStringElement.Children (bufferList = this.Children)
	3.2. Берем нулевой элемент буферного списка, проверяем его NestedLevel на соответствие требуемому. Если соответствует - возвращаем bufferList.
	3.3. Если нет:
		3.3.1 Обнулить returnList
		3.3.2 для каждого элемента bufferList:
			3.3.2.1 добавляем детей элемента в returnList
		3.3.3 когда цикл 3.3.2 закончен, делаем bufferList = returnList
---------------------------------------------------------------------------------------------





































